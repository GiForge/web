<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scanner Documenti - Rettificazione Prospettica</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
    

/* =========================
   RESET
========================= */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: radial-gradient(circle at 20% 10%, #0f172a, #05070d 70%);
    color: #e2faff;
    min-height: 100vh;
    overflow-x: hidden;
}

/* =========================
   CONTAINER GLASS
========================= */
.container {
    max-width: 1400px;
    margin: 0 auto;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    backdrop-filter: blur(12px);
}

/* =========================
   HEADER CYBER
========================= */
.header {
    padding: 24px;
    text-align: center;
    background: linear-gradient(135deg, rgba(0,255,255,0.1), rgba(255,170,0,0.08));
    border-bottom: 1px solid rgba(0,255,255,0.3);
    box-shadow: 0 0 25px rgba(0,255,255,0.15);
}

.header h1 {
    font-size: 1.8rem;
    letter-spacing: 1px;
    color: #00f5ff;
    text-shadow: 0 0 12px #00f5ff;
}

.subtitle {
    font-size: 0.85rem;
    color: #ffb300;
    opacity: 0.9;
}

/* =========================
   CONTROLS BAR
========================= */
.controls {
    padding: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    background: rgba(15,23,42,0.7);
    border-bottom: 1px solid rgba(0,255,255,0.15);
}

/* =========================
   BUTTONS CYBER
========================= */
.btn {
    padding: 12px 16px;
    border-radius: 10px;
    border: 1px solid rgba(0,255,255,0.4);
    background: rgba(0,255,255,0.05);
    color: #00f5ff;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.25s ease;
    backdrop-filter: blur(8px);
}

.btn:hover {
    box-shadow: 0 0 15px rgba(0,255,255,0.6);
    transform: translateY(-2px);
}

.btn-success {
    border-color: rgba(255,170,0,0.5);
    color: #ffb300;
    background: rgba(255,170,0,0.05);
}

.btn-success:hover {
    box-shadow: 0 0 15px rgba(255,170,0,0.6);
}

.btn-secondary {
    border-color: rgba(148,163,184,0.4);
    color: #94a3b8;
}

.btn:disabled {
    opacity: 0.35;
    cursor: not-allowed;
}

/* =========================
   FILTER PANEL
========================= */
.filter-controls {
    width: 100%;
    background: rgba(0,0,0,0.25);
    border: 1px solid rgba(0,255,255,0.15);
    border-radius: 12px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    backdrop-filter: blur(10px);
}

.filter-group label {
    font-size: 13px;
    display: flex;
    justify-content: space-between;
    color: #00f5ff;
}

.filter-group select,
.filter-group input[type="range"] {
    width: 100%;
}

select {
    background: #0f172a;
    border: 1px solid rgba(0,255,255,0.4);
    border-radius: 6px;
    padding: 6px;
    color: #e2faff;
}

input[type="range"] {
    accent-color: #ffb300;
}

/* =========================
   WORKSPACE
========================= */
.workspace {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 12px;
    gap: 12px;
}

/* =========================
   CANVAS CONTAINER
========================= */
.canvas-container {
    position: relative;
    background: rgba(0,0,0,0.5);
    border: 1px solid rgba(0,255,255,0.25);
    border-radius: 16px;
    backdrop-filter: blur(8px);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.canvas-container h3 {
    position: absolute;
    top: 10px;
    left: 12px;
    font-size: 12px;
    background: rgba(0,255,255,0.1);
    padding: 6px 12px;
    border-radius: 20px;
    border: 1px solid rgba(0,255,255,0.4);
    color: #00f5ff;
}

/* =========================
   CANVAS
========================= */
canvas {
    max-width: 100%;
    max-height: 100%;
    border-radius: 12px;
}

/* =========================
   POINTS CYBER
========================= */
.point {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: #00f5ff;
    box-shadow:
        0 0 8px #00f5ff,
        0 0 18px #00f5ff;
    border: 2px solid #000;
}

/* =========================
   VIEW TOGGLE
========================= */
.view-toggle {
    display: flex;
    gap: 6px;
    padding: 8px;
    background: rgba(0,0,0,0.3);
    border-radius: 12px;
    margin: 10px;
}

.view-toggle button {
    flex: 1;
    background: transparent;
    border: 1px solid rgba(0,255,255,0.3);
    border-radius: 8px;
    padding: 8px;
    color: #00f5ff;
}

.view-toggle button.active {
    background: rgba(0,255,255,0.2);
    box-shadow: 0 0 12px #00f5ff;
}

/* =========================
   INSTRUCTIONS
========================= */
.instructions {
    padding: 14px;
    background: rgba(255,170,0,0.05);
    border-top: 1px solid rgba(255,170,0,0.3);
    font-size: 13px;
}

.instructions li {
    color: #ffcc66;
}

/* =========================
   STATUS HUD
========================= */
.status {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    border: 1px solid rgba(0,255,255,0.4);
    color: #00f5ff;
    padding: 12px 20px;
    border-radius: 30px;
    box-shadow: 0 0 20px rgba(0,255,255,0.4);
    backdrop-filter: blur(10px);
}

/* =========================
   DESKTOP LAYOUT
========================= */
@media (min-width: 1024px) {

    .workspace {
        flex-direction: row;
    }

    .canvas-wrapper {
        flex: 1;
    }

    .view-toggle {
        display: none;
    }

}

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ Scanner Documenti Avanzato</h1>
            <p class="subtitle">Rettificazione prospettica e ottimizzazione immagini</p>
        </div>

        <div class="controls">
            <label class="btn btn-primary">
                üìÅ Carica File
                <input type="file" id="fileInput" accept="image/*">
            </label>
            
            <button class="btn btn-primary" id="cameraBtn">
                üì∑ Fotocamera
            </button>

            <button class="btn btn-success" id="rectifyBtn" disabled>
                ‚ú® Rettifica
            </button>

            <button class="btn btn-secondary" id="resetBtn">
                üîÑ Reset
            </button>

            <button class="btn btn-success" id="saveJpgBtn" disabled>
                üíæ JPG
            </button>

            <button class="btn btn-success" id="savePdfBtn" disabled>
                üìë PDF
            </button>

            <div class="filter-controls">
                <div class="filter-group">
                    <label>
                        Modalit√† Colore
                    </label>
                    <select id="colorModeSelect">
                        <option value="color">Colore</option>
                        <option value="grayscale">Scala di Grigi</option>
                        <option value="bw">Bianco e Nero</option>
                    </select>
                </div>

                <div class="filter-group" id="bwThresholdGroup" style="display: none;">
                    <label>
                        Soglia B/N
                        <span class="value" id="thresholdValue">128</span>
                    </label>
                    <input type="range" id="thresholdSlider" min="0" max="255" value="128">
                </div>

                <div class="filter-group">
                    <label>
                        Contrasto
                        <span class="value" id="contrastValue">100%</span>
                    </label>
                    <input type="range" id="contrastSlider" min="50" max="300" value="100">
                </div>

                <div class="filter-group">
                    <label>
                        Luminosit√†
                        <span class="value" id="brightnessValue">100%</span>
                    </label>
                    <input type="range" id="brightnessSlider" min="50" max="250" value="100">
                </div>

                <div class="filter-group">
                    <label>
                        Nitidezza
                        <span class="value" id="sharpnessValue">0</span>
                    </label>
                    <input type="range" id="sharpnessSlider" min="0" max="150" value="0">
                </div>
            </div>
        </div>

        <div class="instructions">
            <h4>üìã Istruzioni:</h4>
            <ul>
                <li>Carica immagine o scatta foto</li>
                <li>Trascina i 4 punti sugli angoli del documento</li>
                <li>Premi "Rettifica" per correggere la prospettiva</li>
                <li>Regola filtri e salva JPG/PDF</li>
            </ul>
        </div>

        <div class="view-toggle">
            <button class="active" data-view="source">üì∑ Originale</button>
            <button data-view="result">‚ú® Risultato</button>
        </div>

        <div class="workspace">
            <div class="canvas-wrapper active" id="sourceWrapper">
                <div class="canvas-container" id="sourceContainer">
                    <h3>Immagine Originale</h3>
                    <canvas id="sourceCanvas"></canvas>
                    <div class="placeholder" id="sourcePlaceholder">
                        Carica un'immagine o usa la fotocamera
                    </div>
                    <div class="zoom-helper" id="zoomHelper">
                        <canvas id="zoomCanvas"></canvas>
                        <div class="crosshair-v"></div>
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper" id="resultWrapper">
                <div class="canvas-container" id="resultContainer">
                    <h3>Risultato Rettificato</h3>
                    <canvas id="resultCanvas"></canvas>
                    <div class="placeholder" id="resultPlaceholder">
                        Il risultato apparir√† qui dopo la rettificazione
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="status" id="status"></div>

<script>
    // 1. ELEMENTI DOM E VARIABILI
    const fileInput = document.getElementById('fileInput');
    const cameraBtn = document.getElementById('cameraBtn');
    const sourceCanvas = document.getElementById('sourceCanvas');
    const resultCanvas = document.getElementById('resultCanvas');
    const sourceCtx = sourceCanvas.getContext('2d');
    const resultCtx = resultCanvas.getContext('2d');
    const sourceContainer = document.getElementById('sourceContainer');
    const rectifyBtn = document.getElementById('rectifyBtn');
    const resetBtn = document.getElementById('resetBtn');
    const saveJpgBtn = document.getElementById('saveJpgBtn');
    const savePdfBtn = document.getElementById('savePdfBtn');
    const contrastSlider = document.getElementById('contrastSlider');
    const brightnessSlider = document.getElementById('brightnessSlider');
    const sharpnessSlider = document.getElementById('sharpnessSlider');
    const colorModeSelect = document.getElementById('colorModeSelect');
    const thresholdSlider = document.getElementById('thresholdSlider');
    const bwThresholdGroup = document.getElementById('bwThresholdGroup');
    const status = document.getElementById('status');

    let sourceImage = null;
    let points = [];
    let pointElements = [];
    let selectedPoint = null;
    let rectifiedImageData = null;

    const zoomHelper = document.getElementById('zoomHelper');
    const zoomCanvas = document.getElementById('zoomCanvas');
    const zoomCtx = zoomCanvas.getContext('2d');

    // 2. GESTIONE INPUT
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => loadImage(event.target.result);
            reader.readAsDataURL(file);
        }
    });

    cameraBtn.addEventListener('click', async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: { ideal: 4096 }, height: { ideal: 2160 } } 
            });
            const video = document.createElement('video');
            video.srcObject = stream;
            await video.play();
            const track = stream.getVideoTracks()[0];
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:10000;display:flex;flex-direction:column;';
            video.style.cssText = 'width:100%;flex-grow:1;object-fit:contain;';
            modal.appendChild(video);
            const controls = document.createElement('div');
            controls.style.cssText = 'padding:20px;display:flex;justify-content:space-around;background:#111;';
            const captureBtn = document.createElement('button');
            captureBtn.innerHTML = 'üì∏ SCATTA';
            captureBtn.className = 'btn btn-primary btn-lg';
            captureBtn.onclick = () => {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvas.getContext('2d').drawImage(video, 0, 0);
                stream.getTracks().forEach(t => t.stop());
                document.body.removeChild(modal);
                loadImage(canvas.toDataURL('image/jpeg', 1.0));
            };
            controls.appendChild(captureBtn);
            modal.appendChild(controls);
            document.body.appendChild(modal);
        } catch (err) { showStatus('Errore: ' + err.message); }
    });

    function loadImage(src) {
        const img = new Image();
        img.onload = () => {
            sourceImage = img;
            const maxWidth = window.innerWidth > 600 ? 600 : window.innerWidth - 40;
            let width = img.width;
            let height = img.height;
            const ratio = Math.min(maxWidth / width, 600 / height);
            width *= ratio; height *= ratio;
            
            sourceCanvas.width = width;
            sourceCanvas.height = height;
            sourceCtx.drawImage(img, 0, 0, width, height);
            document.getElementById('sourcePlaceholder').style.display = 'none';
            sourceCanvas.style.display = 'block';

            const m = 40;
            points = [{x:m, y:m}, {x:width-m, y:m}, {x:width-m, y:height-m}, {x:m, y:height-m}];
            renderPoints();
            rectifyBtn.disabled = false;
            autoRectify();
        };
        img.src = src;
    }

    // 3. TRASCINAMENTO
    function getCanvasCoords(e) {
        const rect = sourceCanvas.getBoundingClientRect();
        return {
            x: (e.clientX - rect.left) * (sourceCanvas.width / rect.width),
            y: (e.clientY - rect.top) * (sourceCanvas.height / rect.height)
        };
    }

    sourceCanvas.addEventListener('pointerdown', (e) => {
        sourceCanvas.setPointerCapture(e.pointerId);
        const coords = getCanvasCoords(e);
        let minDist = 50; 
        selectedPoint = null;
        points.forEach((p, index) => {
            const dist = Math.hypot(p.x - coords.x, p.y - coords.y);
            if (dist < minDist) { minDist = dist; selectedPoint = index; }
        });
        if (selectedPoint !== null) renderPoints();
    });

    sourceCanvas.addEventListener('pointermove', (e) => {
        if (selectedPoint === null) return;
        
        const coords = getCanvasCoords(e);
        
        // Calcolo OFFSET: se il punto √® nella met√† superiore del canvas lo sposto sopra il dito,
        // se √® nella met√† inferiore lo sposto sotto (o viceversa a seconda della comodit√†).
        // Standard: sposta il punto SOPRA il dito di 50px per vederlo meglio.
        const verticalOffset = -50; 
        
        // Applichiamo l'offset solo su mobile/touch (pointerType !== 'mouse')
        const finalY = e.pointerType === 'mouse' ? coords.y : coords.y + verticalOffset;

        points[selectedPoint] = {
            x: Math.max(0, Math.min(sourceCanvas.width, coords.x)),
            y: Math.max(0, Math.min(sourceCanvas.height, finalY))
        };
        
        renderPoints();
        updateZoomHelper(points[selectedPoint].x, points[selectedPoint].y, e.clientX, e.clientY);
    });
    sourceCanvas.addEventListener('pointerup', (e) => {
        if (selectedPoint !== null) {
            sourceCanvas.releasePointerCapture(e.pointerId);
            selectedPoint = null;
            zoomHelper.style.display = 'none';
            renderPoints();
            autoRectify();
        }
    });

    function updateZoomHelper(canvasX, canvasY, screenX, screenY) {
        zoomHelper.style.display = 'block';
        const zw = 160, zh = 160; // Dimensione fissa del widget zoom
        
        // Posizionamento dello zoom (sopra o sotto il dito)
        let left = screenX - zw / 2;
        let top = screenY - zh - 80;
        if (left < 10) left = 10;
        if (top < 10) top = screenY + 60;
        
        zoomHelper.style.left = left + 'px';
        zoomHelper.style.top = top + 'px';

        const scaleX = sourceImage.width / sourceCanvas.width;
        const scaleY = sourceImage.height / sourceCanvas.height;
        
        zoomCanvas.width = zw; 
        zoomCanvas.height = zh;
        zoomCtx.imageSmoothingEnabled = true;

        // --- CALCOLO AREA PROPORZIONALE (Ingrandimento 60%) ---
        // Per avere un ingrandimento del 60%, l'area catturata deve essere 
        // la dimensione del widget divisa per 1.6 (il fattore di zoom).
        const zoomFactor = 2.5; 
        const areaCatturataX = (zw / zoomFactor) * scaleX;
        const areaCatturataY = (zh / zoomFactor) * scaleY;

        zoomCtx.drawImage(
            sourceImage, 
            canvasX * scaleX - areaCatturataX / 2, 
            canvasY * scaleY - areaCatturataY / 2, 
            areaCatturataX, 
            areaCatturataY, 
            0, 0, zw, zh
        );

        // Disegno mirino di precisione
        zoomCtx.strokeStyle = '#3b82f6'; 
        zoomCtx.lineWidth = 2;
        zoomCtx.beginPath(); 
        // Croce
        zoomCtx.moveTo(zw/2, 0); zoomCtx.lineTo(zw/2, zh); 
        zoomCtx.moveTo(0, zh/2); zoomCtx.lineTo(zw, zh/2); 
        zoomCtx.stroke();
        // Cerchio centrale
        zoomCtx.beginPath();
        zoomCtx.arc(zw/2, zh/2, 8, 0, Math.PI * 2);
        zoomCtx.stroke();
    }
    function renderPoints() {
        pointElements.forEach(el => el.remove());
        pointElements = [];
        sourceCtx.drawImage(sourceImage, 0, 0, sourceCanvas.width, sourceCanvas.height);
        sourceCtx.strokeStyle = '#3b82f6'; sourceCtx.lineWidth = 2;
        sourceCtx.beginPath();
        sourceCtx.moveTo(points[0].x, points[0].y);
        points.forEach(p => sourceCtx.lineTo(p.x, p.y));
        sourceCtx.closePath(); sourceCtx.stroke();
        points.forEach((p, i) => {
            const el = document.createElement('div');
            el.className = 'point';
            el.style.cssText = `left:${p.x}px;top:${p.y}px;position:absolute;pointer-events:none;`;
            if (selectedPoint === i) el.style.background = '#fbbf24';
            sourceContainer.appendChild(el);
            pointElements.push(el);
        });
    }

    // 4. MATEMATICA SISTEMI (IMPORTANTE!)
    function solveLinearSystem(A, b) {
        const n = b.length;
        for (let i = 0; i < n; i++) {
            let max = i;
            for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > Math.abs(A[max][i])) max = k;
            [A[i], A[max]] = [A[max], A[i]]; [b[i], b[max]] = [b[max], b[i]];
            for (let k = i + 1; k < n; k++) {
                const f = A[k][i] / A[i][i];
                b[k] -= f * b[i];
                for (let j = i; j < n; j++) A[k][j] -= f * A[i][j];
            }
        }
        const x = new Array(n);
        for (let i = n - 1; i >= 0; i--) {
            x[i] = b[i];
            for (let j = i + 1; j < n; j++) x[i] -= A[i][j] * x[j];
            x[i] /= A[i][i];
        }
        return x;
    }

    function distance(p1, p2) { return Math.sqrt((p2.x-p1.x)**2 + (p2.y-p1.y)**2); }
    function orderPointsClockwise(pts) {
        const center = pts.reduce((acc, p) => ({x:acc.x+p.x/4, y:acc.y+p.y/4}), {x:0, y:0});
        return [...pts].sort((a,b) => Math.atan2(a.y-center.y, a.x-center.x) - Math.atan2(b.y-center.y, b.x-center.x));
    }

    function computeHomography(src, dst) {
        const A = []; const b = [];
        for (let i = 0; i < 4; i++) {
            const {x: sx, y: sy} = src[i];
            const {x: dx, y: dy} = dst[i];
            A.push([sx, sy, 1, 0, 0, 0, -sx * dx, -sy * dx]); b.push(dx);
            A.push([0, 0, 0, sx, sy, 1, -sx * dy, -sy * dy]); b.push(dy);
        }
        const h = solveLinearSystem(A, b);
        return [[h[0], h[1], h[2]], [h[3], h[4], h[5]], [h[6], h[7], 1]];
    }

    function invertHomography(H) {
        const [[a,b,c],[d,e,f],[g,h,i]] = H;
        const det = a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g);
        const invDet = 1/det;
        return [
            [(e*i-f*h)*invDet, (c*h-b*i)*invDet, (b*f-c*e)*invDet],
            [(f*g-d*i)*invDet, (a*i-c*g)*invDet, (c*d-a*f)*invDet],
            [(d*h-e*g)*invDet, (b*g-a*h)*invDet, (a*e-b*d)*invDet]
        ];
    }

    // 5. FILTRI
    function applySharpen(imageData, amount) {
        const w = imageData.width, h = imageData.height;
        const output = new ImageData(new Uint8ClampedArray(imageData.data), w, h);
        const k = [0, -amount, 0, -amount, 1 + 4 * amount, -amount, 0, -amount, 0];
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                const i = (y * w + x) * 4;
                for (let c = 0; c < 3; c++) {
                    let sum = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            sum += imageData.data[((y + ky) * w + (x + kx)) * 4 + c] * k[(ky + 1) * 3 + (kx + 1)];
                        }
                    }
                    output.data[i + c] = sum;
                }
            }
        }
        return output;
    }

    function applyFilters() {
        if (!rectifiedImageData) return;
        
        // Leggiamo i valori una sola volta
        const contrast = Math.pow(contrastSlider.value / 100, 2);
        const brightness = brightnessSlider.value / 100;
        const mode = colorModeSelect.value;
        const thr = parseInt(thresholdSlider.value);
        
        // Creiamo una copia dei dati originali rettificati per non degradare l'immagine a ogni modifica
        let img = new ImageData(
            new Uint8ClampedArray(rectifiedImageData.data), 
            rectifiedImageData.width, 
            rectifiedImageData.height
        );
        
        const d = img.data;
        const len = d.length;

        // Ciclo ottimizzato
        for (let i = 0; i < len; i += 4) {
            let r = d[i], g = d[i+1], b = d[i+2];

            // Conversione colore / Grayscale
            if (mode === 'grayscale' || mode === 'bw') {
                const v = (r * 0.299 + g * 0.587 + b * 0.114);
                r = g = b = v;
            }

            // Contrasto e Luminosit√†
            r = ((r - 128) * contrast + 128) * brightness;
            g = ((g - 128) * contrast + 128) * brightness;
            b = ((b - 128) * contrast + 128) * brightness;

            // Bianco e Nero secco
            if (mode === 'bw') {
                const v = (r + g + b) / 3 > thr ? 255 : 0;
                r = g = b = v;
            }

            d[i] = r; d[i+1] = g; d[i+2] = b;
        }
        
        resultCtx.putImageData(img, 0, 0);
    }

    // 6. RETTIFICA
function autoRectify() {
    if (!sourceImage || points.length < 4) return;

    const ratioX = sourceImage.width / sourceCanvas.width;
    const ratioY = sourceImage.height / sourceCanvas.height;
    const sorted = orderPointsClockwise(points);
    
    // Coordinate reali sulla foto originale
    const realSrc = sorted.map(p => ({ x: p.x * ratioX, y: p.y * ratioY }));

    // --- CALCOLO PROPORZIONI DINAMICHE (Aspect Ratio reale) ---
    // Calcoliamo la larghezza media tra lato superiore e inferiore
    const widthTop = distance(realSrc[0], realSrc[1]);
    const widthBottom = distance(realSrc[3], realSrc[2]);
    const avgW = (widthTop + widthBottom) / 2;

    // Calcoliamo l'altezza media tra lato sinistro e destro
    const heightLeft = distance(realSrc[0], realSrc[3]);
    const heightRight = distance(realSrc[1], realSrc[2]);
    const avgH = (heightLeft + heightRight) / 2;

    // Impostiamo le dimensioni del canvas di output mantenendo il rapporto reale
    const w = Math.round(avgW);
    const h = Math.round(avgH);

    resultCanvas.width = w;
    resultCanvas.height = h;

    // --- OMOGRAFIA ---
    const H = computeHomography(realSrc, [{ x: 0, y: 0 }, { x: w, y: 0 }, { x: w, y: h }, { x: 0, y: h }]);
    const Hinv = invertHomography(H);

    const tCanvas = document.createElement('canvas');
    tCanvas.width = sourceImage.width;
    tCanvas.height = sourceImage.height;
    const tCtx = tCanvas.getContext('2d', { willReadFrequently: true });
    tCtx.drawImage(sourceImage, 0, 0);
    
    const srcData = tCtx.getImageData(0, 0, tCanvas.width, tCanvas.height);
    const dstData = resultCtx.createImageData(w, h);
    
    const sPixels = srcData.data;
    const dPixels = dstData.data;
    const sw = srcData.width;

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const den = Hinv[2][0] * x + Hinv[2][1] * y + Hinv[2][2];
            const sx = Math.floor((Hinv[0][0] * x + Hinv[0][1] * y + Hinv[0][2]) / den);
            const sy = Math.floor((Hinv[1][0] * x + Hinv[1][1] * y + Hinv[1][2]) / den);

            if (sx >= 0 && sx < sw && sy >= 0 && sy < srcData.height) {
                const di = (y * w + x) * 4;
                const si = (sy * sw + sx) * 4;
                dPixels[di] = sPixels[si];
                dPixels[di + 1] = sPixels[si + 1];
                dPixels[di + 2] = sPixels[si + 2];
                dPixels[di + 3] = 255;
            }
        }
    }

    rectifiedImageData = dstData;
    applyFilters();

    // --- FIX APERTURA TAB E VISIBILIT√Ä MOBILE ---
    
    rectifiedImageData = dstData;
    applyFilters();

    // Mostra canvas risultato
    const resPlaceholder = document.getElementById('resultPlaceholder');
    if (resPlaceholder) resPlaceholder.style.display = 'none';

    resultCanvas.style.display = 'block';

    // Attiva vista risultato (mobile + desktop)
    document.getElementById('sourceWrapper').classList.remove('active');
    document.getElementById('resultWrapper').classList.add('active');

    // Aggiorna stato bottoni tab
    document.querySelectorAll('.view-toggle button').forEach(b => {
        b.classList.remove('active');
        if (b.getAttribute('data-view') === 'result') {
            b.classList.add('active');
        }
    });

    // Scroll morbido
    setTimeout(() => {
        resultCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 150);

    saveJpgBtn.disabled = false;
    savePdfBtn.disabled = false;

    showStatus('Documento rettificato con successo');
}

    // 7. LISTENER
    resetBtn.addEventListener('click', () => {
        if (!sourceImage) return;
        const m = 40;
        points = [{x:m, y:m}, {x:sourceCanvas.width-m, y:m}, {x:sourceCanvas.width-m, y:sourceCanvas.height-m}, {x:m, y:sourceCanvas.height-m}];
        renderPoints(); autoRectify();
    });

 // Gestione dei filtri ottimizzata per evitare freeze
    [contrastSlider, brightnessSlider, thresholdSlider, sharpnessSlider].forEach(slider => {
        // Aggiorna il valore numerico a video DURANTE lo spostamento (veloce)
        slider.addEventListener('input', () => {
            const valSpan = document.getElementById(slider.id.replace('Slider', 'Value'));
            if (valSpan) {
                const suffix = slider.id.includes('threshold') ? '' : '%';
                valSpan.textContent = slider.value + suffix;
            }
        });

        // Applica il filtro pesante SOLO al rilascio (evento 'change')
        slider.addEventListener('change', () => {
            showStatus('Applicazione filtri...');
            // Usiamo setTimeout per permettere alla UI di aggiornarsi prima del calcolo pesante
            setTimeout(() => {
                applyFilters();
                showStatus('Filtri applicati');
            }, 10);
        });
    });

    // La modalit√† colore pu√≤ restare su 'change'
    colorModeSelect.addEventListener('change', () => {
        bwThresholdGroup.style.display = colorModeSelect.value === 'bw' ? 'flex' : 'none';
        applyFilters();
    });

    saveJpgBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `scan_${Date.now()}.jpg`;
        link.href = resultCanvas.toDataURL('image/jpeg', 0.95);
        link.click();
    });

    savePdfBtn.addEventListener('click', () => {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: resultCanvas.width > resultCanvas.height ? 'l' : 'p',
            unit: 'px',
            format: [resultCanvas.width, resultCanvas.height]
        });
        pdf.addImage(resultCanvas.toDataURL('image/jpeg', 0.95), 'JPEG', 0, 0, resultCanvas.width, resultCanvas.height);
        pdf.save(`scan_${Date.now()}.pdf`);
    });

    function showStatus(msg) { status.textContent = msg; status.classList.add('show'); setTimeout(()=>status.classList.remove('show'), 2000); }
    
 // Gestione dei Tab su Mobile
    document.querySelectorAll('.view-toggle button').forEach(btn => {
        btn.addEventListener('click', () => {
            // Rimuove classe active dai bottoni
            document.querySelectorAll('.view-toggle button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Mostra/Nasconde i wrapper
            const view = btn.getAttribute('data-view');
            if (view === 'source') {
                document.getElementById('sourceWrapper').classList.add('active');
                document.getElementById('resultWrapper').classList.remove('active');
            } else {
                document.getElementById('sourceWrapper').classList.remove('active');
                document.getElementById('resultWrapper').classList.add('active');
            }
        });
    });
 
</script>
</body>
</html>